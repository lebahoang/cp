package main

import "os"
import "fmt"
import "strconv"
import "bufio"
import "strings"

// set bit j from 0 to 1: A |= (1 << j)
// set bit j from 1 to 0: A &= ^(1 << j)
// check whether bit j is 1 or not: A & (1 << j) != 0
// toggle bit j in A: A ^ (1 << j)
// get state all is bit 1: (1 << n)-1
var pop8tab = [256]uint{

	0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,

	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,

	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,

	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,

	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,

	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,

	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,

	0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
}

func bin(s uint, n uint) string {
	ss := uint64(s)
	t := strconv.FormatUint(ss, 2)
	for {
		if uint(len(t)) < n {
			t = "0" + t
		} else {
			break
		}
	}
	return t
}

func bitCount(x uint) uint {
	return pop8tab[x>>24] + pop8tab[x>>16&0xff] + pop8tab[x>>8&0xff] + pop8tab[x&0xff]
}

func solve(n uint, arr [][]int) int {
	var mod int = 1000000000 + 7
	dp := make([][]int, n)
	for i := uint(0); i < n; i++ {
		dp[i] = make([]int, int(1<<n))
	}
	for j := uint(0); j < n; j++ {
		if arr[0][j] == 1 {
			dp[0][1<<j] = 1
		}

	}
	for i := uint(1); i < n; i++ {
		for j := uint(0); j < n; j++ {
			if arr[i][j] == 1 {
				for x := uint(0); x < (1 << n); x++ {
					if (x&(1<<j)) == 0 && bitCount(x) == i {
						s := x | (1 << j)
						dp[i][s] += dp[i-1][x]
					}
				}
			}
		}
	}
	return dp[n-1][(1<<n)-1] % mod
}

func solve1(n uint, arr [][]int) int {
	var mod int = 1e9 + 7
	dp := make([]int, 1<<n)
	for j := uint(0); j < n; j++ {
		if arr[0][j] == 1 {
			dp[1<<j] = 1
		}
	}
	for x := uint(0); x < (1 << n); x++ {
		i := bitCount(x)
		if i == 0 || i == n {
			continue
		}
		// fmt.Println(i)
		for j := uint(0); j < n; j++ {
			if arr[i][j] == 1 && (x&(1<<j)) == 0 {
				s := x | (1 << j)
				dp[s] = (dp[s]%mod + dp[x]%mod) % mod
			}
		}
	}
	return dp[(1<<n)-1] % mod
}
func main() {
	// var n uint = 3
	// arr := [][]int{
	//     []int{0, 1, 1},
	//     []int{1, 0, 1},
	//     []int{1, 1, 1},
	// }

	// var n uint = 2
	// arr := [][]int{
	//     []int{1, 1},
	//     []int{1, 1},
	// }

	// var n uint = 4
	// arr := [][]int{
	//     []int{0, 1, 0, 0},
	//     []int{0, 0, 0, 1},
	//     []int{1, 0, 0, 0},
	//     []int{0, 0, 1, 0},
	// }

	// var n uint = 21
	// arr := make([][]int, int(n))
	// for i := uint(0); i < n; i++ {
	//     arr[i] = make([]int, int(n))
	// }

	var n uint = 0
	var arr [][]int
	var i uint = 0
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		if i > 0 && i > n {
			break
		}
		if i == 0 {
			t, err := strconv.ParseUint(scanner.Text(), 10, 32)
			if err != nil {
				return
			}
			n = uint(t)
		} else {
			if i == 1 {
				arr = make([][]int, n)
			}
			strs := strings.Split(scanner.Text(), " ")
			arr[i-1] = make([]int, n)
			for j := 0; j < len(strs); j++ {
				t, err := strconv.ParseInt(strs[j], 10, 32)
				if err != nil {
					return
				}
				arr[i-1][j] = int(t)
			}

		}
		i++
	}

	// fmt.Println(n)
	// for i := uint(0); i < n; i++ {
	//     fmt.Println(arr[i])
	// }

	fmt.Println(solve1(n, arr))
}
